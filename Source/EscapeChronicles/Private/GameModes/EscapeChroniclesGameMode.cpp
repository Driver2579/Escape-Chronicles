// Copyright Epic Games, Inc. All Rights Reserved.

#include "EscapeChronicles/Public/GameModes/EscapeChroniclesGameMode.h"

#include "Controllers/PlayerControllers/EscapeChroniclesPlayerController.h"
#include "EscapeChronicles/Public/Characters/EscapeChroniclesCharacter.h"
#include "PlayerStates/EscapeChroniclesPlayerState.h"
#include "Subsystems/SaveGameSubsystem.h"

AEscapeChroniclesGameMode::AEscapeChroniclesGameMode()
{
	DefaultPawnClass = AEscapeChroniclesCharacter::StaticClass();
	PlayerControllerClass = AEscapeChroniclesPlayerController::StaticClass();
	PlayerStateClass = AEscapeChroniclesPlayerState::StaticClass();
}

void AEscapeChroniclesGameMode::InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage)
{
	Super::InitGame(MapName, Options, ErrorMessage);

	USaveGameSubsystem* SaveGameSubsystem = GetWorld()->GetSubsystem<USaveGameSubsystem>();

	if (!ensureAlways(SaveGameSubsystem))
	{
		return;
	}

	SaveGameSubsystem->OnGameLoaded.AddUObject(this, &AEscapeChroniclesGameMode::OnInitialGameLoadFinishedOrFailed);

	SaveGameSubsystem->OnFailedToLoadGame.AddUObject(this,
		&AEscapeChroniclesGameMode::OnInitialGameLoadFinishedOrFailed);

	// Automatically try to load the game when it has started
	SaveGameSubsystem->LoadGameAndInitializeUniquePlayerIDs();
}

FString AEscapeChroniclesGameMode::InitNewPlayer(APlayerController* NewPlayerController,
	const FUniqueNetIdRepl& UniqueId, const FString& Options, const FString& Portal)
{
	const FString ParentResult = Super::InitNewPlayer(NewPlayerController, UniqueId, Options, Portal);

	if (!ensureAlways(NewPlayerController->PlayerState))
	{
		return ParentResult;
	}

	const USaveGameSubsystem* SaveGameSubsystem = GetWorld()->GetSubsystem<USaveGameSubsystem>();

	/**
	 * We can load the joined player from the last save game object that was saved or loaded (if any) only if the
	 * game was already loaded or failed to be loaded. If the loading hasn't finished yet, then just skip loading the
	 * player because he's going to be loaded automatically by the SaveGameSubsystem when the game is loaded.
	 * FUniquePlayerID for this player will be generated by the same logic but also even if the game fails to load.
	 */
	const bool bCanLoadPlayer = ensureAlways(SaveGameSubsystem) && ensureAlways(NewPlayerController->PlayerState) &&
		bInitialGameLoadFinishedOrFailed;

	if (bCanLoadPlayer)
	{
		// If the controller already possesses a pawn, then we can already load the player
		if (IsValid(NewPlayerController->GetPawn()))
		{
			SaveGameSubsystem->LoadPlayerFromCurrentSaveGameObjectOrGenerateUniquePlayerIdForPlayer(
				CastChecked<AEscapeChroniclesPlayerState>(NewPlayerController->PlayerState));
		}
		// Otherwise, wait for the pawn to be possessed
		else
		{
			NewPlayerController->OnPossessedPawnChanged.AddDynamic(this, &ThisClass::OnPlayerToLoadPawnChanged);
		}
	}

	return ParentResult;
}

// ReSharper disable once CppParameterMayBeConstPtrOrRef
void AEscapeChroniclesGameMode::OnPlayerToLoadPawnChanged(APawn* OldPawn, APawn* NewPawn)
{
	if (!IsValid(NewPawn))
	{
		return;
	}

	APlayerController* PlayerController = NewPawn->GetController<APlayerController>();

	if (!ensureAlways(IsValid(PlayerController)))
	{
		return;
	}

	// Stop listening for the new pawn possessed event because we needed it only for the first pawn
	PlayerController->OnPossessedPawnChanged.RemoveDynamic(this, &ThisClass::OnPlayerToLoadPawnChanged);

	const USaveGameSubsystem* SaveGameSubsystem = GetWorld()->GetSubsystem<USaveGameSubsystem>();

	// Load the player once its pawn is possessed
	if (ensureAlways(IsValid(SaveGameSubsystem)))
	{
		SaveGameSubsystem->LoadPlayerFromCurrentSaveGameObjectOrGenerateUniquePlayerIdForPlayer(
			CastChecked<AEscapeChroniclesPlayerState>(NewPawn->GetPlayerState()));
	}
}